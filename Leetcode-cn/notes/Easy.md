- [[1] Two Sum 两数之和](#1-two-sum-两数之和)
- [[7] Reverse Int](#7-reverse-int)
- [[9] isPalindrome](#9-ispalindrome)
- [[14] longestCommonPrefix](#14-longestcommonprefix)
- [[20] Valid Parentheses，判断对等括号](#20-valid-parentheses判断对等括号)
- [[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项](#26-remove-duplicated-from-sorted-array-删除排序数组中的重复项)
- [[27] Remove Element 移除元素](#27-remove-element-移除元素)
- [[28] 实现 strStr()](#28-实现-strstr)
- [[35] Search Insert Position 搜索插入位置](#35-search-insert-position-搜索插入位置)
- [[38] Count and Say 外观数列](#38-count-and-say-外观数列)
- [[53] Maximum Subarray](#53-maximum-subarray)
- [[58] 最后一个单词的长度](#58-最后一个单词的长度)
- [[66] Plus One](#66-plus-one)
- [[67] 二进制求和](#67-二进制求和)
- [[70] 爬楼梯](#70-爬楼梯)
- [[83] 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
- [[88] Merge Sorted Array](#88-merge-sorted-array)
- [[100] 相同的树](#100-相同的树)
- [[101] 对称二叉树](#101-对称二叉树)
- [[104] 二叉树的最大深度](#104-二叉树的最大深度)
- [[107] 二叉树的层次遍历 II](#107-二叉树的层次遍历-ii)
- [[108] 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
- [[110] 平衡二叉树](#110-平衡二叉树)
- [[111] 二叉树的最小深度](#111-二叉树的最小深度)
- [[112] 路径总和](#112-路径总和)
- [[118] 杨辉三角](#118-杨辉三角)
- [[119] 杨辉三角2](#119-杨辉三角2)
- [[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机](#121-best-time-to-buy-and-sell-stock买卖股票的最佳时机)
- [[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II](#122-best-time-to-buy-and-sell-stock-ii买卖股票的最佳时机-ii)
- [[125] 验证回文串](#125-验证回文串)
- [[136] SingleNumber](#136-singlenumber)
- [[141] 环形链表](#141-环形链表)
- [[155] 最小栈](#155-最小栈)
- [[160] 相交链表](#160-相交链表)
- [[167] 两数之和 II - 输入有序数组](#167-两数之和-ii---输入有序数组)
- [[168] Excel表列名称](#168-excel表列名称)
- [[169] 多数元素](#169-多数元素)
- [[171] Excel表列序号](#171-excel表列序号)
- [[172] 阶乘后的零](#172-阶乘后的零)
- [[189] 旋转数组](#189-旋转数组)
- [[190] 颠倒二进制位](#190-颠倒二进制位)
- [[191] 位1的个数](#191-位1的个数)
- [[198] 打家劫舍](#198-打家劫舍)
- [[202] Happy Number](#202-happy-number)
- [[203] 移除链表元素](#203-移除链表元素)
- [[204] 计数质数](#204-计数质数)
- [[205] 同构字符串](#205-同构字符串)
- [[206] Reverse Linked List](#206-reverse-linked-list)
- [[217] 存在重复元素](#217-存在重复元素)
- [[219] 存在重复元素 II](#219-存在重复元素-ii)
- [[225] 用队列实现栈](#225-用队列实现栈)
- [[226] 翻转二叉树](#226-翻转二叉树)
- [[231] 2的幂](#231-2的幂)
- [[232] 用栈实现队列](#232-用栈实现队列)
- [[234] 回文链表](#234-回文链表)
- [[235] 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
- [[237] 删除链表中的节点](#237-删除链表中的节点)
- [[242] 有效的字母异位词](#242-有效的字母异位词)
- [[257] 二叉树的所有路径](#257-二叉树的所有路径)
- [[258] 各位相加](#258-各位相加)
- [[263] 丑数](#263-丑数)
- [[268] 缺失数字](#268-缺失数字)
- [[278] 第一个错误的版本](#278-第一个错误的版本)
- [[283]  Move Zeros，0元素移到最后，其他不变](#283--move-zeros0元素移到最后其他不变)
- [[290] 单词规律](#290-单词规律)
- [[344] 反转字符串](#344-反转字符串)
- [[350] 两个数组的交集 II](#350-两个数组的交集-ii)
- [[367] 有效的完全平方数](#367-有效的完全平方数)
- [[383] 赎金信](#383-赎金信)
- [[387] 字符串中的第一个唯一字符](#387-字符串中的第一个唯一字符)
- [[476] 数字的补数](#476-数字的补数)
- [[496] 下一个更大元素 I](#496-下一个更大元素-i)
- [[543] 二叉树的直径](#543-二叉树的直径)
- [[771] 宝石与石头](#771-宝石与石头)
- [[844] 比较含退格的字符串](#844-比较含退格的字符串)
- [[860] 柠檬水找零](#860-柠檬水找零)
- [[876] 链表的中间结点](#876-链表的中间结点)
- [[993] 二叉树的堂兄弟节点](#993-二叉树的堂兄弟节点)
- [[997] 找到小镇的法官](#997-找到小镇的法官)
- [[1046] 最后一块石头的重量](#1046-最后一块石头的重量)
- [[1232] 缀点成线](#1232-缀点成线)

#### [1] Two Sum 两数之和
- https://leetcode-cn.com/problems/two-sum/
1. Solution1: HashMap
   - `HashMap`存`value`和`index`，遍历判断`target - nums[i]`在不在`HashMap`中
   - 存入时判断，一遍O(n)，Runtime: 100%


#### [7] Reverse Int
- https://leetcode-cn.com/problems/reverse-integer/
- n = n * 10 + x % 10
- 通过`long n == int n`判断是否溢出


#### [9] isPalindrome
- https://leetcode-cn.com/problems/palindrome-number/


#### [14] longestCommonPrefix
- https://leetcode-cn.com/problems/longest-common-prefix
1. 暴力，先内循环选定数组第一个元素，再外循环与数组内其他元素比较
2. 从后往前裁剪至符合，若不符合则裁剪至空


#### [20] Valid Parentheses，判断对等括号
- https://leetcode-cn.com/problems/valid-parentheses/
- 根据 now 指向来 push 对应的括号，判断 pop 是否==对应


#### [26] Remove Duplicated from Sorted Array 删除排序数组中的重复项
- https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
- 只需要前i个，后面不用管
- return的count要+1，因为根据count来print数组


#### [27] Remove Element 移除元素
- https://leetcode-cn.com/problems/remove-element
- 循环中不动即跳过


#### [28] 实现 strStr()
- https://leetcode-cn.com/problems/implement-strstr/description/


#### [35] Search Insert Position 搜索插入位置
- https://leetcode-cn.com/problems/search-insert-position
- once < or = 则返回，为插入位置
- 搜索不到返回 nums.length 即插入最大值位置
- 太巧妙了！



#### [38] Count and Say 外观数列
- https://leetcode-cn.com/problems/count-and-say/description/
- 这题挺有意思


#### [53] Maximum Subarray
- https://leetcode-cn.com/problems/maximum-subarray
1. Solution1: DP, Time: O(n), Space: O(n), Runtime: 93%
   - 初始状态:`dp[0] = nums[0]`
   - 状态转移:`dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])`，若之前数组`sum < 0`，丢弃之前数组，新数组只有`nums[i]`，否则将`nums[i]`加入新数组，继续遍历
   - 遍历过程中存在遍历到负值，不加，维持之前数组的可能。所以另需变量保存遍历过程遇到的数组之和最大值，即结果


#### [58] 最后一个单词的长度
- https://leetcode-cn.com/problems/length-of-last-word/description/


#### [66] Plus One
- https://leetcode-cn.com/problems/plus-one/
- 判断是否进位


#### [67] 二进制求和
- https://leetcode-cn.com/problems/add-binary/description/
- 当前位 = sum % 2，进位 = sum / 2，if (进位 != 0) { append 进位 }


#### [70] 爬楼梯
- https://leetcode-cn.com/problems/climbing-stairs/description/
- 斐波那契数列找规律 ( res[i] = res[i-1]  + res[i-2] )
- **直接递归 ( return res[i-1] + res[i-2] ) 会超时**


#### [83] 删除排序链表中的重复元素
- https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/
- 删除重复节点后若 last 后移一位则会移到已删除的节点上，所以若重复 last 不动，不重复 last 后移一位


#### [88] Merge Sorted Array
- https://leetcode-cn.com/problems/merge-sorted-array/
- 排序好的数组，从后往前插入
- 比大小，大于从尾插，小于则swap
- 剩下直接插在头


#### [100] 相同的树
- https://leetcode-cn.com/problems/same-tree/description/
- 递归写法


#### [101] 对称二叉树
- https://leetcode-cn.com/problems/symmetric-tree/description/
- 从外往内包裹着比较
- 不要想太复杂


#### [104] 二叉树的最大深度
- https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/


#### [107] 二叉树的层次遍历 II
- https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/
- 自顶向下存储，```reverse```后输出
- 完全遍历下一层：
```java
for ( TreeNode node : next_level ){
    vals.add( node.val );
}
```


#### [108] 将有序数组转换为二叉搜索树
- https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/
- 二叉平衡树定义：```left.val < root.val && right.val > root.val```
- 取中间值```(mid = (start + end) / 2)```为root，左边`nums[start, mid - 1]`为左子树，右边`nums[mid + 1, end]`为右子树


#### [110] 平衡二叉树
- https://leetcode-cn.com/problems/balanced-binary-tree/description/
- 中间使用`-1`判断`false`，若`-1`则再次直接`return -1`


#### [111] 二叉树的最小深度
- https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/
- 与 [[104] 二叉树的最大深度 ](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/) 做法类似，https://github.com/joey66666/Algorithms/issues/2#issuecomment-612340952
- 注意区分`root.left != null, root.right != null` 的情况，分开讨论


#### [112] 路径总和
- https://leetcode-cn.com/problems/path-sum/description/
- 到叶子节点判断 `sum - root.val == 0`，没到叶子节点 `sum - root.val`继续递归 `root.left`或`root.right`


#### [118] 杨辉三角
- https://leetcode-cn.com/problems/pascals-triangle/
- [i][0] = 1
- [i][j] = [i-1][j-1] + [i-1][j]


#### [119] 杨辉三角2
- https://leetcode-cn.com/problems/pascals-triangle-ii/
- 设置中间变量保存上一层，与当前层迭代更新


#### [121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/
- 典型DP，把握初始状态（ prices[0] ）和状态转移条件 ( now < start & now_profit > last_profit )



#### [122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/
- **包含当天买入，当天卖出的情况**
- 贪心体现在追求当下利润最大 ( now_profit > 0 )


#### [125] 验证回文串
- https://leetcode-cn.com/problems/valid-palindrome/description/


#### [136] SingleNumber
- https://leetcode-cn.com/problems/single-number/
1. Solution1 HashSet, if ( ! s.add ( x ))  s.remove( x );
2. Solution2 异或运用尤其巧妙，0 ^ int = int，int ^ int = 0;


#### [141] 环形链表
- https://leetcode-cn.com/problems/linked-list-cycle/description/
1. Solution1, 快慢指针，Time: O(n), Space: O(1), Runtime: 100%
   - 循环条件: `fast != null & fast.next != null`
   - 如果用 `slow` 判断，会出现无环的 case 中 `fast` 跑到 `null` 的情况


#### [155] 最小栈
- https://leetcode-cn.com/problems/min-stack/description/
- 用另一个栈保存最小元素，栈顶最小（不是最小push栈顶本身，保证两个栈大小相等）


#### [160] 相交链表
- https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/
- 计算长度差，长的先走到两边平齐，再一起走，相交则return，走到头不相交return null


#### [167] 两数之和 II - 输入有序数组
- https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/
- 头尾指针，头尾和 > target, 尾指针左移；头尾和 < target, 头指针右移
- Time: O(n)


#### [168] Excel表列名称
- https://leetcode-cn.com/problems/excel-sheet-column-title/description/
- 思路：取余到底，转换成字母，再反向输出
- n直接除以26会出错，如`52/26=2···0`，但在Excel用实际`AZ`表示，所以先`n -= 1`。深层原因即计算机以0为第一位，Excel以1为第一位
- `StringBuilder.append()`比`String += `速度快很多


#### [169] 多数元素
- https://leetcode-cn.com/problems/majority-element/description/
1. Solution1: HashMap
   - HashMap，过程中 `if hm.get(nums[i]) > nums.length /2`则return
   - Runtime: 38%
   - Time: O(n), Space: O(n)
2. Solution2: 摩尔投票法
   - 假设 nums[0] 为最多元素，遍历，相同 + 1，不同 - 1
   - 若归零，则前面其他和本身数量相等，对冲抵消，指针当下指向另一个数，换成另一个数，对后面继续遍历比较
   - Runtime: 99%
   -  Time: O(n), Space: O(1)


#### [171] Excel表列序号
- https://leetcode-cn.com/problems/excel-sheet-column-number/description/
- [[168] Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/description/)的反面题
- 等同 26 -> 10 进制转换


#### [172] 阶乘后的零
- https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/
- 0 的个数，即 10 ^ 个数
- 10 = 5 * 2
- 2 的个数易得到，所以10的个数 = 5的个数
- 如15！中有15，10，5，结果为3


#### [189] 旋转数组
- https://leetcode-cn.com/problems/rotate-array/description/
- Solution2, 三次翻转，第一次数组倒序，第二次以k为分界线前后子数组分别倒序
- 比如12345经过翻转就变成了54321，这样已经做到了把前面的数字放到后面去，但是还没有完全达到要求，只需要把12放在后面去，目标数组就是34512。与54321对比发现我们就只需要在把分界线前后数组再进行翻转一次就可得到目标数组了
- Time:O(n) //O(2n)


#### [190] 颠倒二进制位
- https://leetcode-cn.com/problems/reverse-bits/description/
- 思路：把n最右边一位取出来，res左移一位后加到res上，循环移动32次
```
res = res * 2 + n % 2
n /= 2
```
- 以上运算，有符号数下不能用，因为使用补码表示
- 应使用位操作实现：`n & 1`来取最后一位
```
res = (res << 1) | (n & 1)
n >>= 1
```
- Time: O(logN)


#### [191] 位1的个数
- https://leetcode-cn.com/problems/number-of-1-bits/description/
1. Solution1，按位与, Time: O(n), Space: O(1), Runtime: 95%
2. Solution2, 按位与优化, Time: O(logn), Space: O(1), Runtime: 95%
   - n & (n−1) = 把 n 的二进制位中的最低位的 1 变为 0 之后的结果
   - 如：6 & (6-1) = 4, 6 = (110)2, 4 = (100)2, 运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。


#### [198] 打家劫舍
- https://leetcode-cn.com/problems/house-robber/description/
- 维护一个一位数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值，对当前i来说，有抢和不抢两种互斥的选择。
- 不抢：dp[i-1]（等价于去掉 nums[i] 只抢 [0, i-1] 区间最大值）
- 抢：dp[i-2] + nums[i]（等价于去掉 nums[i-1]）
- 比如 nums为{3, 2, 1, 5}，首先 dp[0]=3 , dp[1]，由于3比2大，所以抢第一个房子的3，当前房子的2不抢，则dp[1]=3。dp[2]由于不能抢相邻的，所以可以用再前面的一个的 dp 值加上当前的房间值，和当前房间的前面一个 dp 值比较，取较大值当做当前 dp 值
- 状态转移方程 dp[i] = max(num[i] + dp[i - 2], dp[i - 1]),
- 需要初始化 dp[0] 和 dp[1]，dp[0] 为 num[0]，dp[1] 为 max(num[0], num[1])


#### [202] Happy Number
- https://leetcode-cn.com/problems/happy-number


#### [203] 移除链表元素
- https://leetcode-cn.com/problems/remove-linked-list-elements/description/
- 在`head`前添加头节点(sentinel, dummyHead)
- 双指针遍历删除


#### [204] 计数质数
- https://leetcode-cn.com/problems/count-primes/description/
- 质数：只有1和它本身两个因数的自然数（1不是质数）
- 从boolean[n]数组中，2开始反向去除所有的非质数(2的倍数，3的倍数，4的倍数...)，质数false，非质数true
- 遍历过程使用count记录true的个数


#### [205] 同构字符串
- https://leetcode-cn.com/problems/isomorphic-strings/description/
1. Solution1，HashMap
   - HashMap<Character, Character>存放 s 和 t 的字符映射
   - 遍历，如果遍历到相同的字符hm.get()不同则return false
   - 需要对s和t都要遍历
   - 如"ab","aa"的test case第一次遍历得到['a','a'],['b','a'], 第二次['a','a'],['a','b'] return false
   - Runtime: 64%
2. Solution2，HashMap使用Obejct[]数组重写
   - 字符ASCII码的存放index，值对应HashMap的key，val
   - Runtime: 76%


#### [206] Reverse Linked List
- https://leetcode.com/problems/reverse-linked-list/


#### [217] 存在重复元素#### 
- https://leetcode-cn.com/problems/contains-duplicate/description/
1. Solution1, 简单HashMap/ HashSet, Time: 48%/ 55%
2. Solution2, HashSet比较长度, Time: 70%
   - HashSet特点：无序；不存储重复元素；没有get()，只能iterator访问
   - 遍历一遍存入HashSet，`HashSet.size() < nums.length() ? true : false `
3. 内置流，比较`return Arrays.stream(nums).distinct().count() < nums.length`，Time: 55%
4. 排序后比较`nums[i] == nums[i - 1]`, Time: 99%


#### [219] 存在重复元素 II
- https://leetcode-cn.com/problems/contains-duplicate-ii/description/
- HashMap存Index，每次比较，达条件return true，否则更新Index


#### [225] 用队列实现栈
- https://leetcode-cn.com/problems/implement-stack-using-queues/description/
- 双队列实现，a：临时队列，b：总队列
- 队列a存当前push的数，队列b存之前处理完的完整栈
- 当前push的存到a的头，把b的每一个add到a的尾
- 核心：每次完成add后交换a和b，保证a始终为空


#### [226] 翻转二叉树
- https://leetcode-cn.com/problems/invert-binary-tree/description/
- 递归调换，先进入子树调换完，再调换root.left, root.right


#### [228] 汇总区间
- https://leetcode-cn.com/problems/summary-ranges/description/
1. Solution1, 双指针, Time: O(n), Space: O(1), Runtime: 82%
   - 左右指针，判断遍历到的数和后一个数的差值是否为1，不是则可构成区间


#### [231] 2的幂
- https://leetcode-cn.com/problems/power-of-two/description/
- 2的倍数二进制第一位为1，后面均为0，取最高位异或本身
- 处理 `n <= 0`的情况
- `return (Integer.highestOneBit(n) ^ n) == 0` Runtime: 23%
- `return (Integer.highestOneBit(n) ^ n) == 0 ? true : false` Runtime: 100%


#### [232] 用栈实现队列
- https://leetcode-cn.com/problems/implement-queue-using-stacks/description/
- 双栈`in`和`out`
- Push: `in.push()`
- Pop: 若`out`不为空则`out.pop()`，若`out`空则`out.push(in.pop())`转移所有`in`元素，再`out.pop()`


#### [234] 回文链表
- https://leetcode-cn.com/problems/palindrome-linked-list/description/
- Time: O(n), Space: O(1)
- 1. 快指针指到头时慢指针指到中间
  1. 反向慢指针到结尾之间的节点
  2. 逐个比较前一半和反向过的后一半
   

#### [235] 二叉搜索树的最近公共祖先
- https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/
- 利用二叉搜索树特性：left.val < root.val < right.val
- 若p、q < root 则一定在左子树中，若p、q > root 则一定在右子树中，否则return root


#### [237] 删除链表中的节点
- https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/
- next.val赋值给node,删除下一个node


#### [242] 有效的字母异位词
- https://leetcode-cn.com/problems/valid-anagram/description/
- 三种解法：HashMap, Alphabet Array, Arrays.toCharArray() -> Sort()


#### [257] 二叉树的所有路径
- https://leetcode-cn.com/problems/binary-tree-paths/description/
- traverse()函数，递归深入


#### [258] 各位相加
- https://leetcode-cn.com/problems/add-digits/description/
- 找规律
    

#### [263] 丑数
- https://leetcode-cn.com/problems/ugly-number/description/
- 除到底，判断是否有因子


#### [268] 缺失数字
- https://leetcode-cn.com/problems/missing-number/description/
- 1 - n 相加减去nums中的和


#### [278] 第一个错误的版本
- https://leetcode-cn.com/problems/first-bad-version/description/
- 简单二分，注意循环条件


#### [283]  Move Zeros，0元素移到最后，其他不变
- https://leetcode-cn.com/problems/move-zeroes
1. S1，快慢双指针遍历
2. S2，单指针，非0往前移，统计0个数n；后n个置0


#### [290] 单词规律
- https://leetcode-cn.com/problems/word-pattern/description/
1. Solution
   - 简单HashMap，注意区分a和b的value不能相等，通过加入时判断`hm.containsValue`
   - 使用`Object.equals()`取代 `==` 更健壮


#### [344] 反转字符串#### 
- https://leetcode-cn.com/problems/reverse-string/description/
- 循环到中间


#### [350] 两个数组的交集 II
- https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/
- HashMap两次遍历两个数组


#### [367] 有效的完全平方数
- https://leetcode-cn.com/problems/valid-perfect-square/description/
- 从`left = 0, right = num`开始二分
```java
long mid = left + (right - left) / 2
long t = mid * mid
if(t == num) return true;
else if(t < num) left = mid + 1;
else right = mid - 1; 
```  
- 注意要用`long`数据类型


#### [371] 两整数之和
- https://leetcode-cn.com/problems/sum-of-two-integers/description/
1. Slution1, 位运算，Time: O(n), Space: O(1), Runtime: 100%
   - 模仿计组加法过程
   - `a + b = 有进位 + 无进位`循环
   - `有进位 = a & b/ a & b 再位移` 
   - `无进位 = a ^ b`
   - 把 `b` 加到 `a` 上，循环直到 `b` 为 `0`


#### [383] 赎金信
- https://leetcode-cn.com/problems/ransom-note/description/
- `int[26]`数组遍历`magzine`统计26个字母使用次数，再遍历`ransomNote`, `if 对应字母 <= 0`则return


#### [387] 字符串中的第一个唯一字符
- https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/
1. Solution1， HashMap计次数，遍历两次String
   - Runtime: 30%
   - Time: O(n) //2n
2. 字母表数组计数，原理&Time同HashMap
   - Runtime: 86%


#### [389] 找不同
- https://leetcode-cn.com/problems/find-the-difference/description/
1. Solution1: Time: O(n), Runtime: 100%, Meomory: 51%
   - `char[] alphabet`字母表，跑一遍s, +=1，跑一遍t, -=1，再遍历找到-1的character
2. Solution2: Time: O(n), Runtime: 100%, Meomory: 91%
   - 位操作，按位异或，与自身异或为零


#### [455] 分发饼干
- https://leetcode-cn.com/problems/assign-cookies/description/
1. Solution1: 排序 + 贪心
   - Time: O(nlogn + mlogm), Space: O(logn + logm), Runtime: 89%
   - 尽量使用最小的饼干满足胃口最小的孩子
   - 先排序，再同步遍历两个数组，若当前饼干能满足当前孩子，则均向右移动一个，否则向右移动饼干
   - 优化：
     1. 不能满足该孩子胃口的情况下跳过不符合条件`s[index] < g[child]`的饼干（Runtime未得到优化）


#### [674] 最长连续递增序列
- https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/
1. Solution1, 遍历, Time: O(n), Space: O(1), Runtime: 46%


#### [476] 数字的补数
- https://leetcode-cn.com/problems/number-complement/description/
- 直接 ~ 按位取反，前缀的0也会被取反。
- 所以用 ^ 异或，直接`^1`前面的位数也会异或，用与`num`相同位数的数异或
- 如：101 ^ 111 = 010。怎么得到111？考虑111 + 1 = 1000，而1000又是 最小的 大于101的 只有一位是1 的二进制数。
- 解决方法：
   1. 找到最小的大于原数字的二进制值仅有一位为1的数；
   2. 将此数减1；
   3. 与原数字按位求异或。
- `Integer.highestOneBit(num)`：拿到num最高位，后面补0，如 101 返回 100 


#### [496] 下一个更大元素 I
- https://leetcode-cn.com/problems/next-greater-element-i/description/
- HashMap 简单解法


#### [509] 斐波那契数
- https://leetcode-cn.com/problems/fibonacci-number/description/
1. Solution1: 经典DP, Time: O(n), Space: O(n), Runtime: 100%
   - 按`F(n) = F(n - 1) + F(n - 2)`构建`dp`数组
2. Solution1: 优化DP, Time: O(n), Space: O(1), Runtime: 100%
   - 结果只与三个数有关，使用`i, j, k`三个变量表示计算结果，迭代，`Space`优化到`O(1)`


#### [543] 二叉树的直径
- https://leetcode-cn.com/problems/diameter-of-binary-tree/description/
- **depth = Math.max( depth, left_depth + right_depth )**
- **向上一层 return 1 + Math.max( left_depth, right_depth )**


#### [643] 子数组最大平均数 I
- https://leetcode-cn.com/problems/maximum-average-subarray-i/description/
1. Solution1, Sliding Window, Time: O(n), Space: O(1), Runtime: 100%
   - 固定长度的 `window`，使用 `int count` 取代 `int[] window`，每次移动吐出左边的 `num`，吞下右边的 `num`，移动过程中 `int count` 取代`double`，加速处理，最后返回前除以 `k`


#### [746] 使用最小花费爬楼梯
- https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/
1. Solution1: 经典DP
   - `dp[i] = Math.min((dp[i - 1] + cost[i - 1]),(dp[i - 2] + cost[i - 2]))`


#### [766] 托普利茨矩阵
- https://leetcode-cn.com/problems/toeplitz-matrix/description/
1. Solution1, 遍历, Time: O(mn), Space: O(1), Runtime: 100%
   - 遍历，比较元素和左上角元素是否相等


#### [771] 宝石与石头
- https://leetcode-cn.com/problems/jewels-and-stones/description/
- 简单`HashMap`


#### [830] 较大分组的位置
- https://leetcode-cn.com/problems/positions-of-large-groups/description/
1. Solution1: 双指针
   - `i` 从头遍历, `j` 从 `i` 位置往后遍历，计数，满足条件放入 `List`
   - 当前区间满足条件后需将 `i` 置到 `j` 处，否则会从 `i + 1` 继续遍历，如果存在区间长度 `>= 4` 会出现重复


#### [844] 比较含退格的字符串
- https://leetcode-cn.com/problems/backspace-string-compare/description/
- 栈比字符串性能高挺多


#### [860] 柠檬水找零#### 
- https://leetcode-cn.com/problems/lemonade-change/description/
- 维护两个变量，统计5和10的个数
- 对每个bill需要找零的情况分情况讨论
  - 5: 不找
  - 10: 找5，收10
  - 20: 找三张5，或一张5一张10


#### [876] 链表的中间结点
- https://leetcode-cn.com/problems/middle-of-the-linked-list/description/
- 快慢指针，注意 if( p.next! = null )


#### [888] 公平的糖果交换
- https://leetcode-cn.com/problems/fair-candy-swap/description/
1. Solution1, 暴力，Time: O(n * m), Space: O(1), Runtime: 15%
2. Solution2, 二分，Time: O(max(m, n)), Space: O(1), Runtime: 48%
   - 先计算 `count(A)` 和 `count(B)`的总差值`aCount - (aCount + bCount) / 2`，再 `sort(A), sort(B)` 后双指针遍历
   - 比较 `A[i] - B[j]`与总差值的大小，若大于总差值则表示当前 `B[j]` 不够填补差值，`j += 1`；反之 `i += 1`


#### [993] 二叉树的堂兄弟节点
- https://leetcode-cn.com/problems/cousins-in-binary-tree/description/
- 递归遍历，到x, y节点保存parent和depth
- 最后比较 parent不相等且depth相等


#### [997] 找到小镇的法官
- https://leetcode-cn.com/problems/find-the-town-judge/description/
- 有向图，[a, b]表示从顶点a出发指向顶点b的一条有向边。
- 是否存在且只存在一个顶点，所有的顶点都指向他，但是这个点不指向任何点。
- 即该顶点的入度是N - 1，出度是0。
- 使用一个数组存储每个点的入度和出度的差，当某个点的入度和出度的差是N - 1时，代表他是法官，否则不存在。
- 证明：如果入度和出度的差 = N - 1，又入度、出度 >= 0，那么入度 = N- 1，出度 = 0，满足条件1和2。一旦存在一个点满足条件，那么说明这个点没有出度，所以不存在另一个点的入度是N - 1，满足条件3。


 #### [1018] 可被 5 整除的二进制前缀
- https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/description/
1. Solution1, Time: O(n), Space: O(1), Runtime: 93%
   - 能否被 `5` 整除只与末位有关，所以每次算完一位 `%= 10`，不能暴力算下去，不然 `double` 也会越界
   - `<<= 1` 代替 `*= 2`，加速运算
  

#### [1046] 最后一块石头的重量
- https://leetcode-cn.com/problems/last-stone-weight/


#### [1128] 等价多米诺骨牌对的数量
- https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/description/
1. Solution1, 二元组表示，Time: O(n), Space: O(1), Runtime: 99%
   - `1 <= dominoes[i][j] <= 9` 可得 `i + j <= 99`
   - 使用数组 `i * 10 + j / j * 10 + i` 储存每对的`index`
   - 要计算的是可以有多少对，例如三张相同的牌，可以组成三对 `res = index * (index - 1) / 2` 


#### [1232] 缀点成线
- https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/description/
1. Solution1, 改良斜率法，Time: O(n), Space: O(1), Runtime: 100%
   - 只存在两个点直接 `return`
   - 检查第三个点与12两点之间的斜率是否相等(乘法计算替代除法，防止除数corner case为 `0`)
   - 判断 `Δy1 / Δx1 == Δy2 / Δx2 -> Δy1 * Δx2 == Δx1 * Δy2`, 哪两个`Δ`相乘不要搞错 


#### [1266] 访问所有点的最小时间
- https://leetcode-cn.com/problems/minimum-time-visiting-all-points/description/
- https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/
1. Solution1: 切比雪夫距离
   - 两点 `(x0, y0), (x1, y1)` 之间的距离差为 `dx = Math.abs(x0 - x1), dy = Math.abs(y0 - y1)`
     1. `dx < dy`：沿对角线移动 `dx` 次，再竖直移动 `dy - dx` 次，总计 `dx + (dy - dx) = dy` 次
     2. `dx == dy`：沿对角线移动 `dx` 次
     3.  `dx > dy`：沿对角线移动 `dy` 次，再水平移动 `dx - dy` 次，总计 `dy + (dx - dy) = dx` 次
   - 最少移动次数为 `Math.max(dx, dy)`


#### [1342] 将数字变成 0 的操作次数
- https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/description/
1. Solution1: 奇数 `-1`，偶数 `/2`，Time: O(logn), Space: O(1), Runtime: 100%


#### [1346] 检查整数及其两倍数是否存在
- https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/description/
1. Solution1: HashSet
   - 简单`HashSet`，用`float`加速判断
   - Runtime: 87%


#### [1603] 设计停车系统
- https://leetcode-cn.com/problems/design-parking-system/description/
1. Solution1, 数组模拟, Time: O(1), Space: O(1), Runtime: 100%


#### 剑指 Offer 53 - II. 0～n-1中缺失的数字
- https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/
1. Solution1: 二分，Time: O(logn), Space: O(1), Runtime: 100%
   - **对于有序数组，都应该想到二分**
   - key: 左子数组: `nums[i] == i`; 右子数组: `nums[i] != i`;
   - 二分查找，左右两指针，`left = mid - 1 / right = mid + 1`，迭代，判断，返回